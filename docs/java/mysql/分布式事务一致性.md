# 分布式事务一致性

提到分布式架构就一定绕不开“一致性”问题，而“一致性”其实又包含了**数据一致性**和**事务一致性**两种情况，本文主要讨论事务**一致性**（事务一致性指ACID）。

必须要了解的点：***ACID、CAP、BASE、强一致性、弱一致性、最终一致性***。



## 事务

事务是指由一系列严密的操作组成的一个完整的逻辑过程，这个过程中的所有操作要么都成功，要么都不成功。

### ACID

ACID是事务的四个特性，指的是atomicity，原子性；consistency，一致性；isolation，隔离性；durability，持久性。

1. 原子性(atomicity): 指所有在事务中的操作要么都成功，要么都不成功，所有的操作都不可分割，没有中间状态。一旦某一步执行失败，就会全部回滚到初始状态。
2. 一致性(consistency): 指的是逻辑上的一致性，即所有操作是符合现实当中的期望的。
3. 隔离性(isolation): 即不同事务之间的相互影响和隔离的程度。比如，不同的隔离级别，事务的并发程度也不同，最强的隔离状态是所有的事务都是串行化的（serializable）（即一个事务完成之后才能进行下一个事务），这样并发性也会降到最低，在保证了强一致性的情况下，性能也会受很大影响，所以在实际工程当中，往往会折中一下。
4. 持久性(durability): 可以简单地理解为事务执行完毕后数据不可逆并持久化存储于存储系统当中

### 分布式系统

分布式系统（distributed system）正变得越来越重要，大型网站几乎都是分布式的。

转账是最经典的分布式事务场景，假设用户 A 使用银行 app 发起一笔跨行转账给用户 B，银行系统首先扣掉用户 A 的钱，然后增加用户 B 账户中的余额。

如果其中某个步骤失败，此时就有可能会出现 2 种**「异常」**情况：

- 1.用户 A 的账户扣款成功，用户 B 账户余额增加失败

- 2.用户 A 账户扣款失败，用户 B 账户余额增加成功。

对于银行系统来说，以上 2 种情况都是**「不允许发生」**，此时就需要事务来保证转账操作的成功。

在**「单体应用」**中，我们只需要贴上**[@Transactional](http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247492167&idx=1&sn=02f4f177efef3d689e825c544d7e25b5&chksm=eb506771dc27ee67afc5a0a4d5d2d2082d2706744343bbccba657537ca7bb2403a7583601307&scene=21#wechat_redirect)** 注解就可以开启事务来保证整个操作的**「原子性」**。

举个转账的例子，小明给小红转账100元，如何保证两者账户金额正确？

如果是在同一个系统，同一个数据库管理，可以把两个动作放到一个事务中，利用当个事务的原子性保证金额正确。

```Java
begin transaction; 
// 小明的账户扣减100 
update Account set balance = balance - 100 where user = '小明';
// 小红的账户增加100 
update Account set balance = balance + 100 where user = '小红';
commit;
```



但是看似以上简单的操作，在实际的应用架构中，不可能是单体的服务，我们会把这一系列操作交给**「N个服务」**去完成，也就是拆分成为**「分布式微服务架构」**。

比如下订单服务，扣库存服务等等，必须要**「保证不同服务状态结果的一致性」**，于是就出现了分布式事务。

分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a4461a98cf6421985f948eb2a7b2f5e~tplv-k3u1fbpfcp-watermark.image?)

### CAP

高并发,高可用和一致性三者并不是孤立的,而是互相影响的.

Consistency一致性:是指对于每一次读操作，要么都能够读到最新写入的数据，要么错误。

Availability可用性:是指对于每一次请求，都能够得到一个及时的、非错的响应，但是不保证请求的结果是基于最新写入的数据。

Partition tolerance分区容忍性:是指由于节点之间的网络问题，即使一些消息对包或者延迟，整个系统能继续提供服务（提供一致性或者可用性）。

**为何要保证分区容错性**

CAP 三者不是等同的,并不能通过牺牲一个保证另外两个

CA系统:因为要实现A(高可用)必然要使用冗余,冗余就可能存在网络分区(P

P:需要通过网络基础设备的稳定性来保证,并不能通过牺牲C或A来换取

框架所属EurekaAP(高可用性)ZookeeperCP(强一致性)ConsulCP(强一致性)

### BASE原则

BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写

基本可用 可以保证分布式事务参与方不一定同时在线。软状态 允许系统状态更新有一定的延时，这个延时对客户来说不一定能察觉。最终一致性 通常是通过消息可达的方式保证系统的最终一致性。

CAP&BASE

对于事务我们都知道 ACID，也很熟悉 CAP 理论最多只能满足其中两个，所以，为了提高性能，出现了 ACID 的一个变种 BASE。ACID 强调的是一致性（CAP 中的 C），而 BASE 强调的是可用性（CAP 中的 A）。在很多情况下，我们是无法做到强一致性的 ACID 的。特别是我们需要跨多个系统的时候，而且这些系统还不是由一个公司所提供的。BASE 的系统倾向于设计出更加有弹力的系统，在短时间内，就算是有数据不同步的风险，我们也应该允许新的交易可以发生，而后面我们在业务上将可能出现问题的事务通过补偿的方式处理掉，以保证最终的一致性。



## 什么是分布式事务

在一个分布式系统中各个数据节点之间数据的ACID特性保证.

#### 解决方案

拆分: 

1. 分布式事务-》长事务
2. 本地事务-》短事务
3. 长事务拆分多个短事务

补偿:

A->B->C

A,B成功,C失败

- C不需要补偿

- 补偿B,A



#### **分布式事务的实现主要有以下 6 种方案：**

- XA 方案

- TCC 方案

- SAGA 方案

- 本地消息表

- 可靠消息最终一致性方案

- 最大努力通知方案

- 

### 二阶段提交/XA方案(2PC)

所谓的XA方案，即：两阶段提交，二阶段提交引入一个事务协调者角色来协调管理各个参与者的提交和回滚。

二阶段分别指：准备（投票），提交两个阶段



第一阶段：所有事务参与者，执行后进行预提交,也就是预留事务所需的资源；直到协调者收到所有参与者的预提交才会进入第二步；

- 如果在协调者的超时时间内，有任意参与者的预提交preCommit没发送或未到达，都会结束事务。

第二阶段：所有事务预提交了各自的结果后，由协调者决定最终事务是成功(commit)还是失败(rollback)。



#### 准备阶段

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6f3814ff3274a78baac8acecb13a681~tplv-k3u1fbpfcp-watermark.image?)

#### 提交阶段

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4eebe592d7a4f7e8dc133dd24d18d55~tplv-k3u1fbpfcp-watermark.image?)



#### 缺点：

1.执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。

2.参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。（没有多少容错机制）。

3.二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交，事务容易处于悬而未决的状态。



效率比较低，不适合高并发场景

Spring Boot + JTA 可以实现二阶段提交：

参考地址：https://www.hifreud.com/2017/07/12/spring-boot-23-jta-handle-distribute-transaction/



### TCC（Try-Confirm-Cancel）

TCC 三个方法描述：

- Try：资源的检测和预留(锁定)；

- Confirm：执行**实际的业务操作**提交；要求 Try 成功 Confirm 一定要能成功；

- Cancel：如果任一服务执行出错，那么进行补偿，业务回滚，预留资源释放；



#### 1:TCC设计 - 允许空回滚（Try未执行，Cancel执行了）

Cancel 接口设计时需要允许空回滚。在 Try 接口因为丢包时没有收到，事务管理器会触发回滚，这时会触发 Cancel 接口，这时 Cancel 执行时发现没有对应的事务 xid 或主键时，需要返回回滚成功。让事务服务管理器认为已回滚，否则会不断重试，而 Cancel 又没有对应的业务数据可以进行回滚。

#### 2: TCC设计 - 防悬挂控制（Cancel比Try先执行）

悬挂的意思是：Cancel 比 Try 接口先执行，出现的原因是 Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，但是 Cancel 比 Try 先到。按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致，所以我们在 Cancel 空回滚返回成功之前先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。

#### 3：幂等控制（Try,Confirm,Cancel3个方法均需保证幂等性）

幂等性的意思是：对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。因为网络抖动或拥堵可能会超时，事务管理器会对资源进行重试操作，所以很可能一个业务操作会被重复调用，为了不因为重复调用而多次占用资源，需要对服务设计时进行幂等控制，通常我们可以用事务 xid 或业务主键判重来控制。

最终一致性(消息中间件)



#### 二将军问题（**Two Generals Problem**）

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4545219518874eb2b6d8b414341af3fa~tplv-k3u1fbpfcp-watermark.image?)

如图所示，白军驻扎在沟渠里，蓝军则分散在沟渠两边。白军比任何一支蓝军都更为强大，但是蓝军若能同时合力进攻则能够打败白军。他们不能够远程的沟通，只能派遣通信兵穿过沟渠去通知对方蓝军协商进攻时间。是否存在一个能使蓝军必胜的通信协议，这就是两军问题。

必须注意的是，通信兵得经过敌人的沟渠，在这过程中他可能被捕,也就是说，两军问题中信道是不可靠的，并且其中没有叛徒之说.

倘若1号蓝军（简称1）向2号蓝军（简称2）派出了通信兵，若1要知道2是否收到了自己的信息，1必须要求2给自己传输一个回执，说“你的信息我已经收到了，我同意你提议的明天早上10点9分准时进攻”。

然而，就算2已经送出了这条信息，2也不能确定1就一定会在这个时间进攻，因为2发出的回执1并不一定能够收到。所以，1必须再给2发出一个回执说“我收到了”，但是1也不会知道2是否收到了这样一个回执，所以1还会期待一个2的回执。



由此可见，经典情形下两军问题是不可解的，并不存在一个能使蓝军一定胜利的通信协议。

## Saga方案

1987年Hector & Kenneth 发表论文 Sagas[论文地址](https://link.zhihu.com/?target=https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf)

Saga方案在论文中一个Saga事务就是一个长期运行的事务，这个事务是由多个本地事务所组成， 每个本地事务有相应的执行模块和补偿模块，当saga事务中的任意一个本地事务出错了， 可以通过调用相关事务对应的补偿方法恢复，达到事务的最终一致性。

Saga模型同时支持正向恢复和逆向恢复。正向恢复是指重试当前失败的事务，它的实现前提是每个子事务最终都能够执行成功；逆向恢复则是指在任意一个子事务失败时补偿所有已完成的事务。



Saga模型没有XA协议中的准备阶段，因此事务没有实现隔离性。如果两个Saga事务同时操作同一资源则会产生更新丢失、脏数据读取等问题，这时就需要使用Saga作为事务管理机制的应用程序，在应用层面加入资源锁定的逻辑了。

### 本地消息表

事务状态表(日志)+调用方重试+接收方幂等(保证消息的不重不漏)

对账

弱一致性+基于状态的补偿

重试+回滚+报警+人工修复